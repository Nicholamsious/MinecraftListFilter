import java.io.*;
import java.util.*;

/**
 * The various formats to write the files with.
 */
enum FormattingMode {
    OBSIDIAN, REDDIT, TEXT
}

/**
 * This program takes a list of every .json file in the "assets/minecraft/items" folder that is found by extracting a
 * Minecraft .jar file.
 * It filters through this list, removing, renaming, and adding various items & blocks until it has a list of
 * every obtainable item in survival mode for the given Minecraft version.
 * Therefore, the lists generated by this program will NOT include items and blocks which are only obtainable through
 * creative mode and through commands.
 */
public class Main {
    private static List<String>
            // Substrings appearing in items which will be excluded
            excluding,
            // Food items (meat) to add "Raw " onto as a prefix (as they appear in in-game inventories)
            rawFoodMatches,
            // A list of enchantments to replace the lone "Enchanted Book" with (as they appear in in-game inventories)
            enchantments,
            // A list of regular, splash, and lingering potions to replace "Potion", "Splash potion", and "Lingering potion" with (as they appear in in-game inventories)
            potionItems,
            // A list of arrow variants to replace "Arrow" with (as they appear in in-game inventories)
            arrows,
            // The different ominous bottles to replace "Ominous Bottle" with (as they appear in in-game inventories)
            ominousBottles,
            // The goat horns (labelled by sound) to replace "Goat Horn" with (as they appear in in-game inventories)
            goatHorns,
            // The (output) list of final lines to write to the corresponding file.
            finalLines,
            // The list of strings which, if found matching an element of the long input list, will be marked as "Unstackable"
            unstackablesMatch,
            // For the elements of the long input list which contain any elements of this list (as substrings), they will be marked as "Unstackable"
            unstackablesContain,
            // The list of strings which, if found matching an element of the long input list, will be marked as "(Max x16)"
            stack16Match,
            // For the elements of the long input list which contain any elements of this list (as substrings), they will be marked as "(Max x16)"
            stack16Contain,
            // Strings to remove and replace items which suffix with " Block" with a prefix of "Block of " (as they appear in in-game inventories)
            blockOfReplacements;
    private static String
            // The folder containing the lists of replacements and additions
            inputFilesFolder = "MinecraftListFilter Input Files",
            // The folder holding the files outputted by this program
            outputFilesFolder = "MinecraftListFilter Output File(s)";
    // The java.io.File instances for the input folder and the directory to compile the original long input list from
    private static File inputFilesFolderFile, itemsDirectory;
    // The minecraft version to be displayed in the file names of the output files at the end
    private static String minecraftVersion;
    // The formatting mode currently in use: either OBSIDIAN, REDDIT, or TEXT.
    //private static FormattingMode formattingMode;

    /**
     * Apply final formatting to the item's name.
     * @param formattingMode The formatting mode to use.
     * @param finalNameToFormat The original name to apply the formatting to.
     * @param includeMaximumStackAmounts Include the "Max x16/Max x64/Unstackable" label?
     * @return The formatted item name, ready to write to a list to output.
     */
    public static String formatFinalName(FormattingMode formattingMode, String finalNameToFormat, boolean includeMaximumStackAmounts) {
        if(includeMaximumStackAmounts) {
            // Identify the maximum stack amount.
            int maximumStackAmount = getMaximumStackAmount(finalNameToFormat);
            // Label the item accordingly.
            if (maximumStackAmount > 1) {
                finalNameToFormat += " (Max x" + maximumStackAmount + ")";
            } else if (maximumStackAmount == 1) {
                finalNameToFormat += " (Unstackable)";
            }
        }
        if(formattingMode == FormattingMode.OBSIDIAN) {
            // Format as an Obsidian.md markdown file link.
            // Making each link a VALID file name.
            finalNameToFormat = finalNameToFormat.replaceAll(":", "-");
            finalNameToFormat = "- [[Minecraft " + finalNameToFormat + "]]";
        } else if(formattingMode == FormattingMode.REDDIT) {
            // Format as (markdown) bullet points.
            finalNameToFormat = "- " + finalNameToFormat;
        } else if(formattingMode == FormattingMode.TEXT) {
            // Don't make any changes.
            finalNameToFormat = finalNameToFormat;
        }
        return finalNameToFormat;
    }

    public static File[] listFilesInDirectory(File itemsDirectory) {
        return itemsDirectory.listFiles();
    }

    public static void main(String[] args) {
        printLine("Hello!");
        runMinecraftListFilter();
    }
    public static void runMinecraftListFilter() {
        // Instantiate the folder of input files to read from.
        inputFilesFolderFile = new File(inputFilesFolder);
        // Instantiate the folder containing the item names as .json files.
        itemsDirectory = new File(inputFilesFolder + "/items");
        // Stop the program if neither of the necessary folders exist.
        if(!inputFilesFolderFile.exists() || !itemsDirectory.exists()) {
            printLine("ERROR! items directory not found in folder " + inputFilesFolder +" (which might not exist either). Stopping.");
            return;
        }
        // Prompt the user to enter their target Minecraft version.
        minecraftVersion = getUserInputString("What minecraft version (in numbers and dots)? ");
        // Generate output files with the names only and without the maximum stack sizes.
        filterFilesInAllFormattingModes(itemsDirectory, false);
        // Generate output files with the maximum stack sizes.
        filterFilesInAllFormattingModes(itemsDirectory, true);
    }
    public static void filterFilesInAllFormattingModes(File itemsDirectory, boolean includeMaximumStackAmounts) {
        File[] itemsDirectoryFiles = listFilesInDirectory(itemsDirectory);
        excluding = Arrays.asList("Spawn Egg",
                "Jigsaw",
                "Player Head",
                "Barrier",
                "Bedrock",
                "Command Block",
                "Air",
                "Debug Stick",
                "Dirt Path",
                "End Portal Frame",
                "Farmland",
                "Frogspawn",
                "Infested",
                "Knowledge Book",
                "Petrified Oak Slab",
                "Structure Block",
                "Structure Void",
                "Spawner",
                "Vault",
                "Splash Potion",
                "Potion",
                "Lingering Potion");
        try {
            // Read every input file to populate these lists.
            rawFoodMatches = readFileFromInputFilesFolder("rawfoodmatches.txt");
            enchantments = readFileFromInputFilesFolder("enchantedbooks.txt");
            potionItems = readFileFromInputFilesFolder("potions.txt");
            arrows = readFileFromInputFilesFolder("arrows.txt");
            ominousBottles = readFileFromInputFilesFolder("ominousbottles.txt");
            goatHorns = readFileFromInputFilesFolder("goathorns.txt");
            unstackablesMatch = readFileFromInputFilesFolder("unstackablesmatch.txt");
            unstackablesContain = readFileFromInputFilesFolder("unstackablescontain.txt");
            stack16Match = readFileFromInputFilesFolder("stack16match.txt");
            stack16Contain = readFileFromInputFilesFolder("stack16contain.txt");
            blockOfReplacements = readFileFromInputFilesFolder("blockofreplacements.txt");
            if (itemsDirectoryFiles != null) {
                // Iterate once through each formatting mode.
                for(FormattingMode formattingMode : FormattingMode.values()) {
                    // Reset the list of lines to write to the next file.
                    finalLines = new ArrayList<>();
                    String name;
                    String[] words;
                    String finalName;
                    // Iterate once through each filename found in the items directory (the long list).
                    for (File file : itemsDirectoryFiles) {
                        name = file.getName();
                        // Replace underscores with spaces for readability.
                        name = name.replaceAll("_", " ");
                        // Remove the .json suffix from the name.
                        name = name.substring(0, name.length() - 5);
                        // Reset the final name variable which will hold the final name which will be built.
                        finalName = "";
                        // Split the given name into separate words to prepare it for the comparisons.
                        words = name.split(" ");
                        // Capitalise each word in the name (as it is shown in the in-game inventory).
                        for (String word : words) {
                            finalName += String.valueOf(word.charAt(0)).toUpperCase() + word.substring(1, word.length()) + " ";
                        }
                        // Remove the trailing space on the end of the line after the for loop.
                        finalName = finalName.substring(0, finalName.length() - 1);
                        // SECTION: Explicitly rename items here:
                        finalName = finalName.replaceAll("Tnt", "TNT");
                        finalName = finalName.replaceAll("Writable Book", "Book and Quill");
                        finalName = finalName.replaceAll("Repeater", "Redstone Repeater");
                        finalName = finalName.replaceAll("Comparator", "Redstone Comparator");
                        // SECTION: Replace one item with multiple items:
                        if (finalName.equals("Enchanted Book")) {
                            // Add each enchantment as its own book
                            for (String enchantment : enchantments) {
                                finalName = "Enchanted Book of " + enchantment;
                                finalName = formatFinalName(formattingMode, finalName, includeMaximumStackAmounts);
                                finalLines.add(finalName);
                            }
                            continue;
                        } else if (finalName.equals("Arrow")) {
                            // Add all of the arrow variants
                            for (String arrow : arrows) {
                                finalName = arrow;
                                finalName = formatFinalName(formattingMode, finalName, includeMaximumStackAmounts);
                                finalLines.add(finalName);
                            }
                            continue;
                        } else if (finalName.equals("Potion")) {
                            // Add all of the regular, splash, and lingering potions
                            for (String potion : potionItems) {
                                finalName = potion;
                                finalName = formatFinalName(formattingMode, finalName, includeMaximumStackAmounts);
                                finalLines.add(finalName);
                            }
                            continue;
                        } else if (finalName.equals("Ominous Bottle")) {
                            // Add all of the ominous bottle variants
                            for (String ominousBottle : ominousBottles) {
                                finalName = ominousBottle;
                                finalName = formatFinalName(formattingMode, finalName, includeMaximumStackAmounts);
                                finalLines.add(finalName);
                            }
                            continue;
                        } else if (finalName.equals("Goat Horn")) {
                            // Add all of the goat horn variants
                            for (String goatHorn : goatHorns) {
                                finalName = goatHorn;
                                finalName = formatFinalName(formattingMode, finalName, includeMaximumStackAmounts);
                                finalLines.add(finalName);
                            }
                            continue;
                        } else if (finalName.contains("Copper")) {
                            // Add "Unwaxed" as a prefix to assist readers in identifying unwaxed copper blocks.
                            if (!finalName.contains("Waxed")
                                    && !finalName.contains("Raw")
                                    && !finalName.contains("Ore")
                                    && !finalName.contains("Ingot")) {
                                finalName = "Unwaxed " + finalName;
                            }
                        }
                        // SECTION: Rename individual items into their in-game names:
                        else if (finalName.equals("Experience Bottle")) {
                            finalName = "Bottle o' Enchanting";
                        } else if (finalName.equals("Jack O Lantern")) {
                            finalName = "Jack o'Lantern";
                        } else if (finalName.equals("Turtle Helmet")) {
                            finalName = "Turtle Shell";
                        } else if (finalName.equals("Rabbit Foot")) {
                            finalName = "Rabbit's Foot";
                        } else if (finalName.equals("Dragon Breath")) {
                            finalName = "Dragon's Breath";
                        } else if (finalName.equals("Hay Block")) {
                            finalName = "Hay Bale";
                        } else if (finalName.equals("Smooth Quartz")) {
                            finalName += " Block";
                        } else if (finalName.equals("Redstone")) {
                            finalName += " Dust";
                        } else if (finalName.equals("Map")) {
                            finalName = "Empty Map";
                        } else if (finalName.equals("Flower Banner Pattern")) {
                            finalName = "Flower Charge Banner Pattern";
                        } else if (finalName.equals("Creeper Banner Pattern")) {
                            finalName = "Creeper Charge Banner Pattern";
                        } else if (finalName.equals("Skull Banner Pattern")) {
                            finalName = "Skull Charge Banner Pattern";
                        } else if (finalName.equals("Mojang Banner Pattern")) {
                            finalName = "Thing Banner Pattern";
                        } else if (finalName.equals("Ender Eye")) {
                            finalName = "Eye of Ender";
                        } else if (finalName.equals("Cooked Beef")) {
                            finalName = "Steak";
                        }
                        // SECTION: Rename individual items which contain a specific substring (only necessary for Chest Boat).
                        // Section specifically for vehicles.
                        else if (finalName.contains("Chest Boat")) {
                            finalName = finalName.replace("Chest Boat", "Boat with Chest");
                        } else if (finalName.contains("Chest Minecart")) {
                            finalName = finalName.replace("Chest Minecart", "Minecart with Chest");
                        } else if (finalName.contains("Furnace Minecart")) {
                            finalName = finalName.replace("Furnace Minecart", "Minecart with Furnace");
                        } else if (finalName.contains("Hopper Minecart")) {
                            finalName = finalName.replace("Hopper Minecart", "Minecart with Hopper");
                        } else if (finalName.contains("TNT Minecart")) {
                            finalName = finalName.replace("TNT Minecart", "Minecart with TNT");
                        }
                        // Use skipAhead = true when excluding something.
                        boolean skipAhead = isSkipAhead(finalName);
                        // Replace certain items with suffix " Block" with "Block of " if they appear so in-game.
                        if (finalName.endsWith(" Block")) {
                            for (String replacementSubstring : blockOfReplacements) {
                                // Treat Lapis Lazuli as an odd item because we're inserting a word in the middle.
                                if (replacementSubstring.equals("Lapis Lazuli")) {
                                    if (finalName.equals("Lapis Block")) {
                                        finalName = "Block of Lapis Lazuli";
                                        break;
                                    }
                                } else if (finalName.startsWith(replacementSubstring)) {
                                    finalName = "Block of " + replacementSubstring;
                                    break;
                                }
                            }
                            if (finalName.equals("Waxed Copper Block")) {
                                finalName = "Waxed Block of Copper";
                            } else if (finalName.equals("Unwaxed Copper Block")) {
                                finalName = "Unwaxed Block of Copper";
                            }
                        }
                        if (!skipAhead) {
                            // Rename raw meat to include the word "Raw" as it is so in-game.
                            for (String rawFoodMatch : rawFoodMatches) {
                                if (finalName.equals(rawFoodMatch)) {
                                    finalName = "Raw " + finalName;
                                }
                            }
                            // Format and submit the item's name to the list of lines for the file.
                            finalName = formatFinalName(formattingMode, finalName, includeMaximumStackAmounts);
                            finalLines.add(finalName);
                        }
                    }
                    // Alphabetically sort the lines before writing to the file.
                    Collections.sort(finalLines);
                    // Write to the file.
                    writeObtainableListToFile(formattingMode, outputFilesFolder, minecraftVersion, includeMaximumStackAmounts);
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Skip excluded items.
     * @param finalName The finalName to check.
     * @return true if it should be excluded.
     */
    private static boolean isSkipAhead(String finalName) {
        boolean skipAhead = false;
        // Put exclusions in here.
        // Exclude the "Light" entry.
        if (finalName.equals("Light")) {
            skipAhead = true;
        }
        else if (!finalName.startsWith("Enchanted Book")) {
            // Remove the items containing excluded substrings.
            for (String badSubstring : excluding) {
                if (finalName.contains(badSubstring))
                    skipAhead = true;
            }
        }
        return skipAhead;
    }

    public static void writeObtainableListToFile(FormattingMode formattingMode, String outputFilesFolder, String minecraftVersion, boolean includeMaximumStackAmounts) throws IOException {
        String fileName = "";
        // Choose and build the prefix.
        if(includeMaximumStackAmounts) {
            fileName += "(With stack sizes) ";
        }
        if(formattingMode == FormattingMode.OBSIDIAN) {
            fileName += "Obsidian";
        } else if(formattingMode == FormattingMode.REDDIT) {
            fileName += "Reddit";
        } else if(formattingMode == FormattingMode.TEXT) {
            fileName += "Raw-text";
        }
        // Add the rest of the file name to the prefix.
        fileName += "-formatted List of Minecraft Blocks and Items Obtainable in Survival "+minecraftVersion+".txt";
        // Instantiate the file to write to.
        File fileToWrite = new File(outputFilesFolder + "/"+fileName);
        // If the file doesn't exist, create a new blank file.
        if(!fileToWrite.exists())
            fileToWrite.createNewFile();
        // Write finalLines to the file.
        writeToFile(fileToWrite, finalLines, false);
    }

    /**
     * Print a string to the console (on its own line).
     * @param string What to print to the console.
     */
    public static void printLine(String string) {
        System.out.println(string);
    }

    /**
     * Print a string to the console (on the current/same line).
     * @param string What to print to the console.
     */
    public static void print(String string) {
        System.out.print(string);
    }

    /**
     * Prompt the user for an input of a string, and perform a presence check until a valid value is received.
     * @param prompt The question to ask the user/the prompt to display to the user on the same line where they'll type.
     * @return The valid string value received from the user.
     */
    public static String getUserInputString(String prompt) {
        Scanner scanner = new Scanner(System.in);
        // Prompt the user to enter a value.
        print(prompt);
        String line = scanner.nextLine();
        // Perform a presence check on the user's input.
        while(line.isBlank()) {
            // Alert the user to the error.
            printLine("This can't be blank. Please retry.");
            // Prompt the user for a value again.
            print(prompt);
            line = scanner.nextLine();
        }
        // Return the valid value received.
        return line;
    }
    public static List<String> readFileFromInputFilesFolder(String filenameOrPath) throws IOException {
        // Construct the path for files in the input folder.
        return readFile(inputFilesFolder + "/" + filenameOrPath);
    }

    /**
     * Read a list of lines from a file line by line.
     * @param filenameOrPath The filename or filepath of the file to read from.
     * @return The lines read from the file.
     * @throws IOException If the file doesn't exist (etc.)
     */
    public static List<String> readFile(String filenameOrPath) throws IOException {
        BufferedReader br = new BufferedReader(new FileReader(new File(filenameOrPath)));
        // Prepare an empty list of lines to add to.
        List<String> lines = new ArrayList<>();
        // Read the first line.
        String line = br.readLine();
        // If the previously read line wasn't null, read another line until the end of the document is reached (null).
        while(line != null) {
            lines.add(line);
            line = br.readLine();
        }
        // Close the file.
        br.close();
        // Return the list of lines read.
        return lines;
    }

    /**
     * Write a list of lines to a file.
     * @param file The file to write to.
     * @param lines The lines to write to the file.
     * @param append Choose whether to append these lines (true) or overwrite the file (false).
     * @throws IOException If the file doesn't exist (etc.)
     */
    public static void writeToFile(File file, List<String> lines, boolean append) throws IOException {
        BufferedWriter bw = new BufferedWriter(new FileWriter(file, append));
        // If directed to append to the file, write to it line by line.
        if(append) {
            for (String line : lines) {
                bw.write(line);
            }
        } else {
            // Write all the lines to the file at once, since the instruction is not to append.
            String string = String.join("\n",lines);
            bw.write(string);
        }
        // Flush and close the file.
        bw.flush();
        bw.close();
    }

    /**
     * Identify the maximum stack amount of an item.
     * @param finalLine The item.
     * @return The maximum size of one stack of the given item.
     */
    public static int getMaximumStackAmount(String finalLine) {
        for(String potentialMatch : unstackablesMatch) {
            if(finalLine.equals(potentialMatch)) {
                // Return a maximum stack size of 1 for unstackables.
                return 1;
            }
        }
        for(String potentialMatch : stack16Match) {
            if(finalLine.equals(potentialMatch)) {
                return 16;
            }
        }
        for(String potentialSubstring : unstackablesContain) {
            if(finalLine.contains(potentialSubstring)) {
                // Return a maximum stack size of 1 for unstackables.
                return 1;
            }
        }
        for(String potentialSubstring : stack16Contain) {
            if(finalLine.contains(potentialSubstring)) {
                return 16;
            }
        }
        // If all checks have passed, return a maximum stack size of 64 items.
        return 64;
    }
}